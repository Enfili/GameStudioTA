<!DOCTYPE HTML>
<html
        xmlns:th="http://www.thymeleaf.org"
        xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
        layout:decorate="~{layout/layoutGamestudio.html}"
        lang="sk">
<head>
    <title>Gamestudio - Piskvorky</title>
</head>
<body>
<main layout:fragment="content">
    <h2>Piškvorky</h2>

    <div class="minesControl">
        <span id="score"></span>
        <button type="button" id="btNewGame" class="abutton" onclick="processNewGameClick()">Nová hra</button>
    </div>

    <section style="align-items: center">
        <canvas id="grid" width="600" height="600"></canvas>
    </section>

<script type="text/javascript">

    var grid = document.getElementById("grid");
    const gridWidth = grid.offsetWidth;
    const rowCount = 12;
    const cellWidth = gridWidth / rowCount;
    var context = grid.getContext("2d");
    const score = document.getElementById("score");

    grid.addEventListener("click", addSymbol)

    drawCanvas();
    fetchGrid("/piskvorky/json");

    //------------------------------------
    // CLICKS
    //------------------------------------
    function addSymbol(event) {
        let rect = event.target.getBoundingClientRect();
        let x = event.clientX - rect.left;
        let y = event.clientY - rect.top;

        let row = Math.floor(x / cellWidth);
        let col = Math.floor(y / cellWidth);

        fetchGrid(`/piskvorky/json?row=${row}&column=${col}`);
    }

    function processNewGameClick() {
        context.clearRect(0, 0, gridWidth, gridWidth);
        drawCanvas();
        fetchGrid("/piskvorky/jsonnew");
    }

    //------------------------------------
    // FETCHING
    //------------------------------------
    function fetchGrid(url) {
        fetch(url)
            .then(response => {
                if (response.ok) {
                    return response.json();
                } else {
                    return Promise.reject(new Error(`Grid acquisition failed. Server answered with ${response.status}: ${response.statusText}.`));
                }
            })
            .then(gridData => {
                score.innerHTML = `<span style="color:blue; font-size:200%;">${gridData.score[0]}</span>
                                   <span style="font-size:200%">:</span>
                                   <span style="color:red; font-size:200%;">${gridData.score[1]}</span>`;
                drawSymbols(gridData);
                drawCrossLines(gridData);
            })
            .catch(error => { ////here we process all the failed promises
                errorMessage = "Nepodarilo sa získať alebo zobraziť herné pole zo servera. Podrobnosti: " + error;
                console.log(errorMessage);
            });
    }

    //------------------------------------
    // DRAWING
    //------------------------------------
    function drawCanvas() {
        context.strokeStyle = "black";
        context.lineWidth = 1;
        context.beginPath();
        for (let i = 0; i <= rowCount; i++) {
            context.moveTo(i * cellWidth, 0);
            context.lineTo(i * cellWidth, gridWidth);
            context.stroke();
        }
        for (let i = 0; i <= rowCount; i++) {
            context.moveTo(0, i * cellWidth);
            context.lineTo(gridWidth, i * cellWidth);
            context.stroke();
        }
    }

    function drawSymbols(gridData) {
        context.lineWidth = 4;
        for (let row = 0; row < rowCount; row++) {
            for (let col = 0; col < rowCount; col++) {
                if (gridData.board[row][col].state == "CIRCLE") {
                    context.moveTo(row * cellWidth, col * cellWidth);
                    context.beginPath();
                    context.arc(row * cellWidth + (cellWidth / 2), col * cellWidth + (cellWidth / 2), cellWidth / 2, 0, 2 * Math.PI);
                    context.strokeStyle = "blue";
                    context.stroke();
                } else if (gridData.board[row][col].state == "CROSS") {
                    context.strokeStyle = "red";
                    context.beginPath();
                    context.moveTo(row * cellWidth, col * cellWidth);
                    context.lineTo(row * cellWidth + cellWidth, col * cellWidth + cellWidth);
                    context.stroke();
                    context.moveTo(row * cellWidth + cellWidth, col * cellWidth);
                    context.lineTo(row * cellWidth, col * cellWidth + cellWidth);
                    context.stroke();
                }
            }
        }
    }

    function drawCrossLines(gridData) {
        context.lineWidth = 4;

        let nbOfCrossedSymbols = gridData.crossedSymbols.right.length;
        for (line = 0; line < nbOfCrossedSymbols; line++) {
            if (gridData.crossedSymbols.right[line].state == "CIRCLE") {
                context.strokeStyle = "blue";
                drawLine(gridData.crossedSymbols.right[line].position[0], gridData.crossedSymbols.right[line].position[1], "right");
            } else {
                context.strokeStyle = "red";
                drawLine(gridData.crossedSymbols.right[line].position[0], gridData.crossedSymbols.right[line].position[1], "right");
            }
        }
        nbOfCrossedSymbols = gridData.crossedSymbols.down.length;
        for (line = 0; line < nbOfCrossedSymbols; line++) {
            if (gridData.crossedSymbols.down[line].state == "CIRCLE") {
                context.strokeStyle = "blue";
                drawLine(gridData.crossedSymbols.down[line].position[0], gridData.crossedSymbols.down[line].position[1], "down");
            } else {
                context.strokeStyle = "red";
                drawLine(gridData.crossedSymbols.down[line].position[0], gridData.crossedSymbols.down[line].position[1], "down");
            }
        }
        nbOfCrossedSymbols = gridData.crossedSymbols.upRight.length;
        for (line = 0; line < nbOfCrossedSymbols; line++) {
            if (gridData.crossedSymbols.upRight[line].state == "CIRCLE") {
                context.strokeStyle = "blue";
                drawLine(gridData.crossedSymbols.upRight[line].position[0], gridData.crossedSymbols.upRight[line].position[1], "upRight");
            } else {
                context.strokeStyle = "red";
                drawLine(gridData.crossedSymbols.upRight[line].position[0], gridData.crossedSymbols.upRight[line].position[1], "upRight");
            }
        }
        nbOfCrossedSymbols = gridData.crossedSymbols.downRight.length;
        for (line = 0; line < nbOfCrossedSymbols; line++) {
            if (gridData.crossedSymbols.downRight[line].state == "CIRCLE") {
                context.strokeStyle = "blue";
                drawLine(gridData.crossedSymbols.downRight[line].position[0], gridData.crossedSymbols.downRight[line].position[1], "downRight");
            } else {
                context.strokeStyle = "red";
                drawLine(gridData.crossedSymbols.downRight[line].position[0], gridData.crossedSymbols.downRight[line].position[1], "downRight");
            }
        }
    }

    function drawLine(row, col, dir) {
        if (dir == "right") {
            context.beginPath();
            context.moveTo(row * cellWidth, col * cellWidth  + (cellWidth / 2));
            context.lineTo(row * cellWidth + 5 * cellWidth, col * cellWidth  + (cellWidth / 2));
            context.stroke();
        } else if (dir == "down") {
            context.beginPath();
            context.moveTo(row * cellWidth + (cellWidth / 2), col * cellWidth);
            context.lineTo(row * cellWidth + (cellWidth / 2), col * cellWidth + 5 * cellWidth);
            context.stroke();
        } else if (dir == "upRight") {
            context.beginPath();
            context.moveTo(row * cellWidth, col * cellWidth + cellWidth);
            context.lineTo(row * cellWidth + 5 * cellWidth, col * cellWidth - 4 * cellWidth);
            context.stroke();
        } else if (dir == "downRight") {
            context.beginPath();
            context.moveTo(row * cellWidth, col * cellWidth);
            context.lineTo(row * cellWidth + 5 * cellWidth, col * cellWidth + 5 * cellWidth);
            context.stroke();
        }
    }


</script>
</main>
</body>
</html>


<!--    <section>-->
<!--        <table if="board" class="minefield">-->
<!--            <tr th:each="row: ${board}">-->
<!--                <td th:each="symbol: ${row}">-->
<!--                    <a th:if="${@piskvorkyController.getCellText(symbol) == ' '}" th:attr="href='/piskvorky?row='+${rowStat.index}+'&column='+${symbolStat.index}">-->
<!--                        <span th:text="${@piskvorkyController.getCellText(symbol)}"></span>-->
<!--                    </a>-->
<!--                    <span th:if="${@piskvorkyController.getCellText(symbol) == 'O'}" style="color:blue;">O</span>-->
<!--                    <span th:if="${@piskvorkyController.getCellText(symbol) == 'X'}" style="color:red;">X</span>-->
<!--                </td>-->
<!--            </tr>-->
<!--        </table>-->
<!--    </section>-->
