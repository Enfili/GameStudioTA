<!DOCTYPE HTML>
<html
        xmlns:th="http://www.thymeleaf.org"
        xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
        layout:decorate="~{layout/layoutGamestudio.html}"
        lang="sk">
<head>
    <title>Gamestudio - Kamene</title>
</head>
<body>
<main layout:fragment="content">
    <h2>Kamene</h2>

    <div class="minesControl">
        <span id="gameStatus"></span>
        <button type="button" id="btNewGame" class="abutton">Nová hra</button>
    </div>

    <section id="field"></section>

    <section>
        <h3>Najlepšie skóre</h3>
        <table class="scores">
            <thead>
            <tr>
                <th>Poradie</th>
                <th>Meno</th>
                <th>Body</th>
                <th>Dátum a čas hry</th>
            </tr>
            </thead>
            <tbody id="scoresTableBody">
            </tbody>
        </table>
    </section>

    <script type="text/javascript">

        let elements = {
            field: document.getElementById("field"),
            scoresTableBody: document.getElementById("scoresTableBody")
        }

        fetchAndRenderScores("/api/score/kamene", elements);
        fetchAndRenderField("/kamene/json", elements);

        //---------------------fetching

        function fetchAndRenderScores(url, elements) {
            fetch(url)  //there may be a second parameter, an object wih options, but we do not need it now.
                .then(response => {      //fetch promise fullfilled (operation completed successfully)
                    if (response.ok) {    //successful execution includes an error response from the server. So we have to check the return status of the response here.
                        return response.json(); //we return a new promise with the response data as a js object, constructed from the JSON string in the response
                    } else { //if we get server error
                        return Promise.reject(new Error(`Best scores acquisition failed. Server answered with ${response.status}: ${response.statusText}.`)); //we return a rejected promise to be catched later
                    }
                })
                .then(bestScoresData => { //here we process the returned response data in JSON ...
                    console.log(bestScoresData);
                    renderBestScores(bestScoresData, elements);
                })
                .catch(error => { ////here we process all the failed promises
                    errorMessage = "Nepodarilo sa získať alebo zobraziť údaje o najlepších skóre. Podrobnosti: " + error;
                    // console.log(errorMessage);
                    elements.scoresTableBody.innerHTML = errorMessage;
                });
        }

        function fetchAndRenderField(url, elements) {
            fetch(url)  //there may be a second parameter, an object wih options, but we do not need it now.
                .then(response => {      //fetch promise fullfilled (operation completed successfully)
                    if (response.ok) {    //successful execution includes an error response from the server. So we have to check the return status of the response here.
                        return response.json(); //we return a new promise with the response data as a js object, constructed from the JSON string in the response
                    } else { //if we get server error
                        return Promise.reject(new Error(`Best scores acquisition failed. Server answered with ${response.status}: ${response.statusText}.`)); //we return a rejected promise to be catched later
                    }
                })
                .then(fieldData => { //here we process the returned response data in JSON ...
                    console.log(fieldData);
                    renderField(fieldData, elements);
                })
                .catch(error => { ////here we process all the failed promises
                    errorMessage = "Nepodarilo sa získať alebo zobraziť údaje o najlepších skóre. Podrobnosti: " + error;
                    // console.log(errorMessage);
                    elements.field.innerHTML = errorMessage;
                });
        }

        //-------------------rendering
        function renderBestScores(bestScoresData, elements) {
            const rowCount = bestScoresData.length;
            let htmlToRender = "";

            for (row = 0; row < rowCount; row++) {
                htmlToRender +=
                    `<tr>
                   <td>
                       ${row + 1}
                   </td>
                   <td>
                       ${bestScoresData[row].username}
                   </td>
                   <td>
                       ${bestScoresData[row].points}
                   </td>
                   <td>
                       ${bestScoresData[row].playedOn}
                   </td>
                </tr>
               `;

                elements.scoresTableBody.innerHTML = htmlToRender;
            }
        }

        function renderField(fieldData, elements) {
            let htmlToRender = "<table class='minefield'>\n";

            for (row = 0; row < fieldData.rowCount; row++) {
                htmlToRender += "<tr>\n";
                for (col = 0; col < fieldData.columnCount; col++) {
                    htmlToRender +=
                        `<td>
                            <span>${getStoneText(fieldData.stones[row][col])}</span>
                         </td>`;
                }
                htmlToRender += "</tr>\n";
            }

            elements.field.innerHTML = htmlToRender;
        }

        function getStoneText(stone) {
            if (stone != null)
                return stone.value;
            else
                return " ";
        }

    </script>

</main>
</body>
</html>